#!/usr/bin/env dart

import 'dart:io';
import 'converters/color_converter.dart';

/// Comprehensive custom token generator that creates both custom classes and extensions
class CustomTokenGenerator {
  final Map<String, dynamic> config;
  
  CustomTokenGenerator(this.config);

  /// Generate all custom token classes and extensions
  static Future<void> generateAll() async {
    final configFile = File('fly-config.yaml');
    
    if (!configFile.existsSync()) {
      print('Error: fly-config.yaml not found');
      print('Please create a fly-config.yaml file with your custom tokens');
      exit(1);
    }
    
    final configContent = await configFile.readAsString();
    final config = _parseYaml(configContent);
    
    final generator = CustomTokenGenerator(config);
    
    print('Generating custom FlyWind design tokens...\n');
    
    // Generate custom token classes
    if (config['extend']?['colors'] != null) {
      await generator._generateCustomColors();
    }
    
    if (config['extend']?['spacing'] != null) {
      await generator._generateCustomSpacing();
    }
    
    if (config['extend']?['radius'] != null) {
      await generator._generateCustomRadius();
    }
    
    if (config['extend']?['breakpoint'] != null) {
      await generator._generateCustomBreakpoint();
    }
    
    if (config['extend']?['container'] != null) {
      await generator._generateCustomContainer();
    }
    
    if (config['extend']?['text'] != null) {
      await generator._generateCustomText();
    }
    
    if (config['extend']?['text_line_height'] != null) {
      await generator._generateCustomTextLineHeight();
    }
    
    if (config['extend']?['font_weight'] != null) {
      await generator._generateCustomFontWeight();
    }
    
    if (config['extend']?['tracking'] != null) {
      await generator._generateCustomTracking();
    }
    
    if (config['extend']?['blur'] != null) {
      await generator._generateCustomBlur();
    }
    
    if (config['extend']?['perspective'] != null) {
      await generator._generateCustomPerspective();
    }
    
    if (config['extend']?['leading'] != null) {
      await generator._generateCustomLeading();
    }
    
    // Generate the main custom tokens file
    await generator._generateCustomTokensFile();
    
    print('Custom token generation completed!');
  }

  /// Generate custom colors class
  Future<void> _generateCustomColors() async {
    final colors = config['extend']['colors'] as Map<String, dynamic>;
    if (colors.isEmpty) return;
    
    print('Generating custom colors...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln("import '../tokens/color.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom colors that provide dot notation access to custom color values');
    buffer.writeln('class CustomColors {');
    buffer.writeln('  const CustomColors._();');
    buffer.writeln();
    
    // Generate custom color properties
    for (final entry in colors.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterColor = _convertColorValue(value);
      
      buffer.writeln('  /// Custom color: $key');
      buffer.writeln('  static const Color $fieldName = $flutterColor;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyColorToken with custom extras
    buffer.writeln('  /// Create default custom colors as FlyColorToken');
    buffer.writeln('  static FlyColorToken defaultColors() {');
    buffer.writeln('    return FlyColorToken.defaultColor().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in colors.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterColor = _convertColorValue(value);
      buffer.writeln("        '$key': $flutterColor,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyColorToken to provide dot notation access');
    buffer.writeln('extension FlyColorTokenExtensions on FlyColorToken {');
    
    for (final entry in colors.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterColor = _convertColorValue(value);
      
      buffer.writeln('  /// Custom color: $key');
      buffer.writeln('  Color get $fieldName => extras[\'$key\'] ?? $flutterColor;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/colors.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom colors: ${colors.keys.join(', ')}');
  }

  /// Generate custom spacing class
  Future<void> _generateCustomSpacing() async {
    final spacing = config['extend']['spacing'] as Map<String, dynamic>;
    if (spacing.isEmpty) return;
    
    print('Generating custom spacing...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/spacing.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom spacing that provide dot notation access to custom spacing values');
    buffer.writeln('class CustomSpacing {');
    buffer.writeln('  const CustomSpacing._();');
    buffer.writeln();
    
    // Generate custom spacing properties
    for (final entry in spacing.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertSpacingValue(value);
      
      buffer.writeln('  /// Custom spacing: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlySpacingToken with custom extras
    buffer.writeln('  /// Create default custom spacing as FlySpacingToken');
    buffer.writeln('  static FlySpacingToken defaultSpacing() {');
    buffer.writeln('    return FlySpacingToken.defaultSpacing().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in spacing.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertSpacingValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlySpacingToken to provide dot notation access');
    buffer.writeln('extension FlySpacingTokenExtensions on FlySpacingToken {');
    
    for (final entry in spacing.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertSpacingValue(value);
      
      buffer.writeln('  /// Custom spacing: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/spacing.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom spacing: ${spacing.keys.join(', ')}');
  }

  /// Generate custom radius class
  Future<void> _generateCustomRadius() async {
    final radius = config['extend']['radius'] as Map<String, dynamic>;
    if (radius.isEmpty) return;
    
    print('Generating custom radius...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/radius.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom radius that provide dot notation access to custom radius values');
    buffer.writeln('class CustomRadius {');
    buffer.writeln('  const CustomRadius._();');
    buffer.writeln();
    
    // Generate custom radius properties
    for (final entry in radius.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertRadiusValue(value);
      
      buffer.writeln('  /// Custom radius: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyRadiusToken with custom extras
    buffer.writeln('  /// Create default custom radius as FlyRadiusToken');
    buffer.writeln('  static FlyRadiusToken defaultRadius() {');
    buffer.writeln('    return FlyRadiusToken.defaultRadius().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in radius.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertRadiusValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyRadiusToken to provide dot notation access');
    buffer.writeln('extension FlyRadiusTokenExtensions on FlyRadiusToken {');
    
    for (final entry in radius.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertRadiusValue(value);
      
      buffer.writeln('  /// Custom radius: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/radius.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom radius: ${radius.keys.join(', ')}');
  }


  /// Generate custom breakpoint class
  Future<void> _generateCustomBreakpoint() async {
    final breakpoint = config['extend']['breakpoint'] as Map<String, dynamic>;
    if (breakpoint.isEmpty) return;
    
    print('Generating custom breakpoint...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/breakpoint.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom breakpoint that provide dot notation access to custom breakpoint values');
    buffer.writeln('class CustomBreakpoint {');
    buffer.writeln('  const CustomBreakpoint._();');
    buffer.writeln();
    
    // Generate custom breakpoint properties
    for (final entry in breakpoint.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom breakpoint: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyBreakpointToken with custom extras
    buffer.writeln('  /// Create default custom breakpoint as FlyBreakpointToken');
    buffer.writeln('  static FlyBreakpointToken defaultBreakpoint() {');
    buffer.writeln('    return FlyBreakpointToken.defaultBreakpoint().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in breakpoint.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyBreakpointToken to provide dot notation access');
    buffer.writeln('extension FlyBreakpointTokenExtensions on FlyBreakpointToken {');
    
    for (final entry in breakpoint.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom breakpoint: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/breakpoint.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom breakpoint: ${breakpoint.keys.join(', ')}');
  }

  /// Generate custom container class
  Future<void> _generateCustomContainer() async {
    final container = config['extend']['container'] as Map<String, dynamic>;
    if (container.isEmpty) return;
    
    print('Generating custom container...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/container.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom container that provide dot notation access to custom container values');
    buffer.writeln('class CustomContainer {');
    buffer.writeln('  const CustomContainer._();');
    buffer.writeln();
    
    // Generate custom container properties
    for (final entry in container.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom container: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyContainerToken with custom extras
    buffer.writeln('  /// Create default custom container as FlyContainerToken');
    buffer.writeln('  static FlyContainerToken defaultContainer() {');
    buffer.writeln('    return FlyContainerToken.defaultContainer().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in container.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyContainerToken to provide dot notation access');
    buffer.writeln('extension FlyContainerTokenExtensions on FlyContainerToken {');
    
    for (final entry in container.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom container: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/container.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom container: ${container.keys.join(', ')}');
  }

  /// Generate custom text class
  Future<void> _generateCustomText() async {
    final text = config['extend']['text'] as Map<String, dynamic>;
    if (text.isEmpty) return;
    
    print('Generating custom text...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/text.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom text that provide dot notation access to custom text values');
    buffer.writeln('class CustomText {');
    buffer.writeln('  const CustomText._();');
    buffer.writeln();
    
    // Generate custom text properties
    for (final entry in text.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom text: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyTextToken with custom extras
    buffer.writeln('  /// Create default custom text as FlyTextToken');
    buffer.writeln('  static FlyTextToken defaultText() {');
    buffer.writeln('    return FlyTextToken.defaultText().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in text.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyTextToken to provide dot notation access');
    buffer.writeln('extension FlyTextTokenExtensions on FlyTextToken {');
    
    for (final entry in text.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom text: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/text.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom text: ${text.keys.join(', ')}');
  }

  /// Generate custom text line height class
  Future<void> _generateCustomTextLineHeight() async {
    final textLineHeight = config['extend']['text_line_height'] as Map<String, dynamic>;
    if (textLineHeight.isEmpty) return;
    
    print('Generating custom text line height...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/text_line_height.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom text line height that provide dot notation access to custom text line height values');
    buffer.writeln('class CustomTextLineHeight {');
    buffer.writeln('  const CustomTextLineHeight._();');
    buffer.writeln();
    
    // Generate custom text line height properties
    for (final entry in textLineHeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom text line height: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyTextLineHeightToken with custom extras
    buffer.writeln('  /// Create default custom text line height as FlyTextLineHeightToken');
    buffer.writeln('  static FlyTextLineHeightToken defaultTextLineHeight() {');
    buffer.writeln('    return FlyTextLineHeightToken.defaultTextLineHeight().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in textLineHeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyTextLineHeightToken to provide dot notation access');
    buffer.writeln('extension FlyTextLineHeightTokenExtensions on FlyTextLineHeightToken {');
    
    for (final entry in textLineHeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom text line height: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/text_line_height.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom text line height: ${textLineHeight.keys.join(', ')}');
  }

  /// Generate custom font weight class
  Future<void> _generateCustomFontWeight() async {
    final fontWeight = config['extend']['font_weight'] as Map<String, dynamic>;
    if (fontWeight.isEmpty) return;
    
    print('Generating custom font weight...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln("import '../tokens/font_weight.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom font weight that provide dot notation access to custom font weight values');
    buffer.writeln('class CustomFontWeight {');
    buffer.writeln('  const CustomFontWeight._();');
    buffer.writeln();
    
    // Generate custom font weight properties
    for (final entry in fontWeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertFontWeightValue(value);
      
      buffer.writeln('  /// Custom font weight: $key');
      buffer.writeln('  static const FontWeight $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyFontWeightToken with custom extras
    buffer.writeln('  /// Create default custom font weight as FlyFontWeightToken');
    buffer.writeln('  static FlyFontWeightToken defaultFontWeight() {');
    buffer.writeln('    return FlyFontWeightToken.defaultFontWeight().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in fontWeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertFontWeightValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyFontWeightToken to provide dot notation access');
    buffer.writeln('extension FlyFontWeightTokenExtensions on FlyFontWeightToken {');
    
    for (final entry in fontWeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertFontWeightValue(value);
      
      buffer.writeln('  /// Custom font weight: $key');
      buffer.writeln('  FontWeight get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/font_weight.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom font weight: ${fontWeight.keys.join(', ')}');
  }

  /// Generate custom tracking class
  Future<void> _generateCustomTracking() async {
    final tracking = config['extend']['tracking'] as Map<String, dynamic>;
    if (tracking.isEmpty) return;
    
    print('Generating custom tracking...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/tracking.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom tracking that provide dot notation access to custom tracking values');
    buffer.writeln('class CustomTracking {');
    buffer.writeln('  const CustomTracking._();');
    buffer.writeln();
    
    // Generate custom tracking properties
    for (final entry in tracking.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom tracking: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyTrackingToken with custom extras
    buffer.writeln('  /// Create default custom tracking as FlyTrackingToken');
    buffer.writeln('  static FlyTrackingToken defaultTracking() {');
    buffer.writeln('    return FlyTrackingToken.defaultTracking().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in tracking.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyTrackingToken to provide dot notation access');
    buffer.writeln('extension FlyTrackingTokenExtensions on FlyTrackingToken {');
    
    for (final entry in tracking.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom tracking: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/tracking.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom tracking: ${tracking.keys.join(', ')}');
  }

  /// Generate custom blur class
  Future<void> _generateCustomBlur() async {
    final blur = config['extend']['blur'] as Map<String, dynamic>;
    if (blur.isEmpty) return;
    
    print('Generating custom blur...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/blur.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom blur that provide dot notation access to custom blur values');
    buffer.writeln('class CustomBlur {');
    buffer.writeln('  const CustomBlur._();');
    buffer.writeln();
    
    // Generate custom blur properties
    for (final entry in blur.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom blur: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyBlurToken with custom extras
    buffer.writeln('  /// Create default custom blur as FlyBlurToken');
    buffer.writeln('  static FlyBlurToken defaultBlur() {');
    buffer.writeln('    return FlyBlurToken.defaultBlur().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in blur.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyBlurToken to provide dot notation access');
    buffer.writeln('extension FlyBlurTokenExtensions on FlyBlurToken {');
    
    for (final entry in blur.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom blur: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/blur.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom blur: ${blur.keys.join(', ')}');
  }

  /// Generate custom perspective class
  Future<void> _generateCustomPerspective() async {
    final perspective = config['extend']['perspective'] as Map<String, dynamic>;
    if (perspective.isEmpty) return;
    
    print('Generating custom perspective...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/perspective.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom perspective that provide dot notation access to custom perspective values');
    buffer.writeln('class CustomPerspective {');
    buffer.writeln('  const CustomPerspective._();');
    buffer.writeln();
    
    // Generate custom perspective properties
    for (final entry in perspective.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom perspective: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyPerspectiveToken with custom extras
    buffer.writeln('  /// Create default custom perspective as FlyPerspectiveToken');
    buffer.writeln('  static FlyPerspectiveToken defaultPerspective() {');
    buffer.writeln('    return FlyPerspectiveToken.defaultPerspective().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in perspective.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyPerspectiveToken to provide dot notation access');
    buffer.writeln('extension FlyPerspectiveTokenExtensions on FlyPerspectiveToken {');
    
    for (final entry in perspective.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom perspective: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/perspective.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom perspective: ${perspective.keys.join(', ')}');
  }

  /// Generate custom leading class
  Future<void> _generateCustomLeading() async {
    final leading = config['extend']['leading'] as Map<String, dynamic>;
    if (leading.isEmpty) return;
    
    print('Generating custom leading...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/leading.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom leading that provide dot notation access to custom leading values');
    buffer.writeln('class CustomLeading {');
    buffer.writeln('  const CustomLeading._();');
    buffer.writeln();
    
    // Generate custom leading properties
    for (final entry in leading.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom leading: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyLeadingToken with custom extras
    buffer.writeln('  /// Create default custom leading as FlyLeadingToken');
    buffer.writeln('  static FlyLeadingToken defaultLeading() {');
    buffer.writeln('    return FlyLeadingToken.defaultLeading().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in leading.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyLeadingToken to provide dot notation access');
    buffer.writeln('extension FlyLeadingTokenExtensions on FlyLeadingToken {');
    
    for (final entry in leading.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);
      
      buffer.writeln('  /// Custom leading: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/config/leading.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom leading: ${leading.keys.join(', ')}');
  }

  /// Generate the main custom tokens file
  Future<void> _generateCustomTokensFile() async {
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add exports
    if (config['extend']?['colors'] != null) {
      buffer.writeln("export 'colors.dart';");
    }
    if (config['extend']?['spacing'] != null) {
      buffer.writeln("export 'spacing.dart';");
    }
    if (config['extend']?['radius'] != null) {
      buffer.writeln("export 'radius.dart';");
    }
    if (config['extend']?['breakpoint'] != null) {
      buffer.writeln("export 'breakpoint.dart';");
    }
    if (config['extend']?['container'] != null) {
      buffer.writeln("export 'container.dart';");
    }
    if (config['extend']?['text'] != null) {
      buffer.writeln("export 'text.dart';");
    }
    if (config['extend']?['text_line_height'] != null) {
      buffer.writeln("export 'text_line_height.dart';");
    }
    if (config['extend']?['font_weight'] != null) {
      buffer.writeln("export 'font_weight.dart';");
    }
    if (config['extend']?['tracking'] != null) {
      buffer.writeln("export 'tracking.dart';");
    }
    if (config['extend']?['blur'] != null) {
      buffer.writeln("export 'blur.dart';");
    }
    if (config['extend']?['perspective'] != null) {
      buffer.writeln("export 'perspective.dart';");
    }
    if (config['extend']?['leading'] != null) {
      buffer.writeln("export 'leading.dart';");
    }
    
    // Write the file
    final outputFile = File('lib/config/config.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
  }

  /// Convert key to valid Dart field name (camelCase)
  static String _getFieldName(String key) {
    if (key.isEmpty) {
      return 'defaultValue';
    }

    // Handle purely numeric keys (e.g., "4" -> "s4")
    if (RegExp(r'^\d+$').hasMatch(key)) {
      return 's$key';
    }

    // Handle keys that start with numbers (e.g., "2xl" -> "xl2", "3xs" -> "xs3")
    final numberPrefixMatch = RegExp(r'^(\d+)([a-zA-Z]+)$').firstMatch(key);
    if (numberPrefixMatch != null) {
      final number = numberPrefixMatch.group(1)!;
      final letters = numberPrefixMatch.group(2)!;
      return '${letters.toLowerCase()}$number';
    }

    // Convert to camelCase and handle other patterns
    final parts = key.split(RegExp(r'[^a-zA-Z0-9]+'));
    if (parts.isEmpty) return 'value';

    final firstPart = parts[0].toLowerCase();
    final remainingParts = parts.skip(1).map((part) {
      if (part.isEmpty) return '';
      return part[0].toUpperCase() + part.substring(1).toLowerCase();
    });

    return firstPart + remainingParts.join('');
  }

  /// Convert color value to Flutter Color
  String _convertColorValue(String value) {
    if (value.startsWith('#')) {
      return ColorConverter.hexToFlutterColor(value);
    } else {
      return 'const Color(0xFF000000)'; // fallback
    }
  }

  /// Convert spacing value to Flutter double
  String _convertSpacingValue(String value) {
    final doubleValue = double.tryParse(value) ?? 0.0;
    return doubleValue.toString();
  }

  /// Convert radius value to Flutter double
  String _convertRadiusValue(String value) {
    final doubleValue = double.tryParse(value) ?? 0.0;
    return doubleValue.toString();
  }

  /// Convert double value to Flutter double
  String _convertDoubleValue(String value) {
    final doubleValue = double.tryParse(value) ?? 0.0;
    return doubleValue.toString();
  }

  /// Convert font weight value to Flutter FontWeight
  String _convertFontWeightValue(String value) {
    final intValue = int.tryParse(value) ?? 400;
    
    // Clamp to valid FontWeight values (100-900, in steps of 100)
    final clampedValue = (intValue / 100).round() * 100;
    final validValue = clampedValue.clamp(100, 900);
    
    return 'FontWeight.w$validValue';
  }

  /// Simple YAML parser for the config file
  static Map<String, dynamic> _parseYaml(String content) {
    final result = <String, dynamic>{};
    final lines = content.split('\n');
    
    String? currentSection;
    Map<String, dynamic>? currentMap;
    Map<String, dynamic>? currentSubMap;
    
    for (final line in lines) {
      final trimmed = line.trim();
      
      if (trimmed.isEmpty || trimmed.startsWith('#')) {
        continue;
      }
      
      if (trimmed == 'extend:') {
        currentSection = 'extend';
        result[currentSection] = <String, dynamic>{};
        currentMap = result[currentSection];
        continue;
      }
      
      if (currentSection == 'extend' && trimmed.endsWith(':') && !trimmed.contains(' ')) {
        final key = trimmed.substring(0, trimmed.length - 1);
        currentSubMap = <String, dynamic>{};
        currentMap![key] = currentSubMap;
        continue;
      }
      
      if (currentSubMap != null && trimmed.contains(':')) {
        final parts = trimmed.split(':');
        if (parts.length >= 2) {
          final key = parts[0].trim();
          final value = parts.sublist(1).join(':').trim().replaceAll("'", '');
          currentSubMap[key] = value;
        }
      }
    }
    
    return result;
  }
}

Future<void> main(List<String> args) async {
  if (args.isNotEmpty && (args[0] == '--help' || args[0] == '-h')) {
    print('Usage: dart generate/generate_custom.dart');
    print('');
    print('This script generates custom FlyWind design token classes and extensions');
    print('that provide dot notation access to custom values');
    print('');
    print('The script will generate:');
    print('  - CustomColors class with static properties');
    print('  - CustomSpacing class with static properties');
    print('  - CustomRadius class with static properties');
    print('  - CustomBreakpoint class with static properties');
    print('  - CustomContainer class with static properties');
    print('  - CustomText class with static properties');
    print('  - CustomTextLineHeight class with static properties');
    print('  - CustomFontWeight class with static properties');
    print('  - CustomTracking class with static properties');
    print('  - CustomBlur class with static properties');
    print('  - CustomPerspective class with static properties');
    print('  - CustomLeading class with static properties');
    print('  - Extension methods for all FlyToken types');
    print('');
    print('Generated files will be placed in lib/config/');
    print('  - colors.dart (instead of custom_colors.dart)');
    print('  - spacing.dart (instead of custom_spacing.dart)');
    print('  - radius.dart (instead of custom_radius.dart)');
    print('  - breakpoint.dart (instead of custom_breakpoint.dart)');
    print('  - container.dart (instead of custom_container.dart)');
    print('  - text.dart (instead of custom_text.dart)');
    print('  - text_line_height.dart (instead of custom_text_line_height.dart)');
    print('  - font_weight.dart (instead of custom_font_weight.dart)');
    print('  - tracking.dart (instead of custom_tracking.dart)');
    print('  - blur.dart (instead of custom_blur.dart)');
    print('  - perspective.dart (instead of custom_perspective.dart)');
    print('  - leading.dart (instead of custom_leading.dart)');
    print('  - config.dart (instead of custom_tokens.dart)');
    return;
  }
  
  await CustomTokenGenerator.generateAll();
}
