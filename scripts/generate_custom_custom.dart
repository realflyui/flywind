#!/usr/bin/env dart

import 'dart:io';
import 'converters/color_converter.dart';

/// Comprehensive custom token generator that creates both custom classes and extensions
class CustomTokenGenerator {
  final Map<String, dynamic> config;
  
  CustomTokenGenerator(this.config);

  /// Generate all custom token classes and extensions
  static Future<void> generateAll() async {
    final configFile = File('fly-config.yaml');
    
    if (!configFile.existsSync()) {
      print('Error: fly-config.yaml not found');
      print('Please create a fly-config.yaml file with your custom tokens');
      exit(1);
    }
    
    final configContent = await configFile.readAsString();
    final config = _parseYaml(configContent);
    
    final generator = CustomTokenGenerator(config);
    
    print('Generating custom FlyWind design tokens...\n');
    
    // Generate custom token classes
    if (config['extend']?['colors'] != null) {
      await generator._generateCustomColors();
    }
    
    if (config['extend']?['spacing'] != null) {
      await generator._generateCustomSpacing();
    }
    
    if (config['extend']?['radius'] != null) {
      await generator._generateCustomRadius();
    }
    
    // Generate the main custom tokens file
    await generator._generateCustomTokensFile();
    
    print('Custom token generation completed!');
  }

  /// Generate custom colors class
  Future<void> _generateCustomColors() async {
    final colors = config['extend']['colors'] as Map<String, dynamic>;
    if (colors.isEmpty) return;
    
    print('Generating custom colors...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln("import '../tokens/color.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom colors that provide dot notation access to custom color values');
    buffer.writeln('class CustomColors {');
    buffer.writeln('  const CustomColors._();');
    buffer.writeln();
    
    // Generate custom color properties
    for (final entry in colors.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterColor = _convertColorValue(value);
      
      buffer.writeln('  /// Custom color: $key');
      buffer.writeln('  static const Color $fieldName = $flutterColor;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyColorToken with custom extras
    buffer.writeln('  /// Create default custom colors as FlyColorToken');
    buffer.writeln('  static FlyColorToken defaultColors() {');
    buffer.writeln('    return FlyColorToken.defaultColor().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in colors.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterColor = _convertColorValue(value);
      buffer.writeln("        '$key': $flutterColor,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyColorToken to provide dot notation access');
    buffer.writeln('extension FlyColorTokenExtensions on FlyColorToken {');
    
    for (final entry in colors.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterColor = _convertColorValue(value);
      
      buffer.writeln('  /// Custom color: $key');
      buffer.writeln('  Color get $fieldName => extras[\'$key\'] ?? $flutterColor;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/custom_tokens/custom_colors.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom colors: ${colors.keys.join(', ')}');
  }

  /// Generate custom spacing class
  Future<void> _generateCustomSpacing() async {
    final spacing = config['extend']['spacing'] as Map<String, dynamic>;
    if (spacing.isEmpty) return;
    
    print('Generating custom spacing...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/spacing.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom spacing that provide dot notation access to custom spacing values');
    buffer.writeln('class CustomSpacing {');
    buffer.writeln('  const CustomSpacing._();');
    buffer.writeln();
    
    // Generate custom spacing properties
    for (final entry in spacing.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertSpacingValue(value);
      
      buffer.writeln('  /// Custom spacing: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlySpacingToken with custom extras
    buffer.writeln('  /// Create default custom spacing as FlySpacingToken');
    buffer.writeln('  static FlySpacingToken defaultSpacing() {');
    buffer.writeln('    return FlySpacingToken.defaultSpacing().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in spacing.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertSpacingValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlySpacingToken to provide dot notation access');
    buffer.writeln('extension FlySpacingTokenExtensions on FlySpacingToken {');
    
    for (final entry in spacing.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertSpacingValue(value);
      
      buffer.writeln('  /// Custom spacing: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/custom_tokens/custom_spacing.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom spacing: ${spacing.keys.join(', ')}');
  }

  /// Generate custom radius class
  Future<void> _generateCustomRadius() async {
    final radius = config['extend']['radius'] as Map<String, dynamic>;
    if (radius.isEmpty) return;
    
    print('Generating custom radius...');
    
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add imports
    buffer.writeln("import '../tokens/radius.dart';");
    buffer.writeln();
    
    // Add class documentation
    buffer.writeln('/// Custom radius that provide dot notation access to custom radius values');
    buffer.writeln('class CustomRadius {');
    buffer.writeln('  const CustomRadius._();');
    buffer.writeln();
    
    // Generate custom radius properties
    for (final entry in radius.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertRadiusValue(value);
      
      buffer.writeln('  /// Custom radius: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();
    
    // Generate default method that creates a FlyRadiusToken with custom extras
    buffer.writeln('  /// Create default custom radius as FlyRadiusToken');
    buffer.writeln('  static FlyRadiusToken defaultRadius() {');
    buffer.writeln('    return FlyRadiusToken.defaultRadius().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in radius.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertRadiusValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();
    
    // Add extension methods for dot notation
    buffer.writeln('/// Extension methods for FlyRadiusToken to provide dot notation access');
    buffer.writeln('extension FlyRadiusTokenExtensions on FlyRadiusToken {');
    
    for (final entry in radius.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertRadiusValue(value);
      
      buffer.writeln('  /// Custom radius: $key');
      buffer.writeln('  double get $fieldName => extras[\'$key\'] ?? $flutterValue;');
    }
    
    buffer.writeln('}');
    
    // Write the file
    final outputFile = File('lib/custom_tokens/custom_radius.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
    print('Custom radius: ${radius.keys.join(', ')}');
  }


  /// Generate the main custom tokens file
  Future<void> _generateCustomTokensFile() async {
    final buffer = StringBuffer();
    
    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by generate_custom.dart');
    buffer.writeln('// To regenerate, run: dart generate/generate_custom.dart');
    buffer.writeln('//');
    buffer.writeln();
    
    // Add exports
    if (config['extend']?['colors'] != null) {
      buffer.writeln("export 'custom_colors.dart';");
    }
    if (config['extend']?['spacing'] != null) {
      buffer.writeln("export 'custom_spacing.dart';");
    }
    if (config['extend']?['radius'] != null) {
      buffer.writeln("export 'custom_radius.dart';");
    }
    
    // Write the file
    final outputFile = File('lib/custom_tokens/custom_tokens.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(buffer.toString());
    
    print('Generated: ${outputFile.path}');
  }

  /// Convert key to valid Dart field name (camelCase)
  static String _getFieldName(String key) {
    if (key.isEmpty) {
      return 'defaultValue';
    }

    // Handle purely numeric keys (e.g., "4" -> "s4")
    if (RegExp(r'^\d+$').hasMatch(key)) {
      return 's$key';
    }

    // Handle keys that start with numbers (e.g., "2xl" -> "xl2", "3xs" -> "xs3")
    final numberPrefixMatch = RegExp(r'^(\d+)([a-zA-Z]+)$').firstMatch(key);
    if (numberPrefixMatch != null) {
      final number = numberPrefixMatch.group(1)!;
      final letters = numberPrefixMatch.group(2)!;
      return '${letters.toLowerCase()}$number';
    }

    // Convert to camelCase and handle other patterns
    final parts = key.split(RegExp(r'[^a-zA-Z0-9]+'));
    if (parts.isEmpty) return 'value';

    final firstPart = parts[0].toLowerCase();
    final remainingParts = parts.skip(1).map((part) {
      if (part.isEmpty) return '';
      return part[0].toUpperCase() + part.substring(1).toLowerCase();
    });

    return firstPart + remainingParts.join('');
  }

  /// Convert color value to Flutter Color
  String _convertColorValue(String value) {
    if (value.startsWith('#')) {
      return ColorConverter.hexToFlutterColor(value);
    } else {
      return 'const Color(0xFF000000)'; // fallback
    }
  }

  /// Convert spacing value to Flutter double
  String _convertSpacingValue(String value) {
    final doubleValue = double.tryParse(value) ?? 0.0;
    return doubleValue.toString();
  }

  /// Convert radius value to Flutter double
  String _convertRadiusValue(String value) {
    final doubleValue = double.tryParse(value) ?? 0.0;
    return doubleValue.toString();
  }

  /// Simple YAML parser for the config file
  static Map<String, dynamic> _parseYaml(String content) {
    final result = <String, dynamic>{};
    final lines = content.split('\n');
    
    String? currentSection;
    Map<String, dynamic>? currentMap;
    Map<String, dynamic>? currentSubMap;
    
    for (final line in lines) {
      final trimmed = line.trim();
      
      if (trimmed.isEmpty || trimmed.startsWith('#')) {
        continue;
      }
      
      if (trimmed == 'extend:') {
        currentSection = 'extend';
        result[currentSection] = <String, dynamic>{};
        currentMap = result[currentSection];
        continue;
      }
      
      if (currentSection == 'extend' && trimmed.endsWith(':') && !trimmed.contains(' ')) {
        final key = trimmed.substring(0, trimmed.length - 1);
        currentSubMap = <String, dynamic>{};
        currentMap![key] = currentSubMap;
        continue;
      }
      
      if (currentSubMap != null && trimmed.contains(':')) {
        final parts = trimmed.split(':');
        if (parts.length >= 2) {
          final key = parts[0].trim();
          final value = parts.sublist(1).join(':').trim().replaceAll("'", '');
          currentSubMap[key] = value;
        }
      }
    }
    
    return result;
  }
}

Future<void> main(List<String> args) async {
  if (args.isNotEmpty && (args[0] == '--help' || args[0] == '-h')) {
    print('Usage: dart generate/generate_custom.dart');
    print('');
    print('This script generates custom FlyWind design token classes and extensions');
    print('that provide dot notation access to custom values');
    print('');
    print('The script will generate:');
    print('  - CustomColors class with static properties');
    print('  - CustomSpacing class with static properties');
    print('  - CustomRadius class with static properties');
    print('  - Extension methods for FlySpacingToken');
    print('  - Extension methods for FlyColorToken');
    print('  - Extension methods for FlyRadiusToken');
    print('');
    print('Generated files will be placed in lib/custom_tokens/');
    return;
  }
  
  await CustomTokenGenerator.generateAll();
}
