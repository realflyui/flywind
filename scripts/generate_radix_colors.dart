import 'dart:io';

import 'package:path/path.dart' as path;

/// Generate const Color constants from P3 color scales
///
/// This script reads P3 color strings from radix_color_scales.dart
/// and generates a file with const Color objects for IDE color previews.
void main() {
  // Read the scales file
  final scalesFile = File(
    path.join(path.current, 'lib', 'theme', 'radix_color_scales.dart'),
  );

  if (!scalesFile.existsSync()) {
    print('Error: radix_color_scales.dart not found');
    exit(1);
  }

  final content = scalesFile.readAsStringSync();

  // Parse P3 maps from the file
  final lightScales = _parseP3Map(content, 'radixLightScalesP3');
  final darkScales = _parseP3Map(content, 'radixDarkScalesP3');

  if (lightScales.isEmpty || darkScales.isEmpty) {
    print('Error: Could not parse P3 scales from file');
    exit(1);
  }

  // Generate the constants file
  final output = _generateConstantsFile(lightScales, darkScales);

  // Write to file
  final outputFile = File(
    path.join(path.current, 'lib', 'theme', 'radix_color_constants.dart'),
  );

  outputFile.writeAsStringSync(output);
  print('Generated: ${outputFile.path}');
  print(
    'Generated ${lightScales.length} light scales and ${darkScales.length} dark scales',
  );

  // Insert step properties directly into RadixColors class
  _insertStepPropertiesIntoRadixColors(lightScales);

  // Insert dark step properties into RadixDarkColors class
  _insertDarkStepPropertiesIntoRadixColorsDark(darkScales);

  // Insert context-aware step properties into RadixColorScheme class
  _insertContextStepPropertiesIntoRadixColorsContext(lightScales, darkScales);
}

/// Parse a P3 map from the source file
Map<String, List<String>> _parseP3Map(String content, String mapName) {
  final scales = <String, List<String>>{};

  // Find the map definition
  final mapRegex = RegExp(
    'const Map<String, List<String>> $mapName = \\{([\\s\\S]*?)\\};',
  );
  final match = mapRegex.firstMatch(content);

  if (match == null) {
    return scales;
  }

  final mapContent = match.group(1)!;

  // Match scale entries: 'scaleName': [ ... ]
  final scaleRegex = RegExp(r"'(\w+)':\s*\[([^\]]+)\]", multiLine: true);

  for (final scaleMatch in scaleRegex.allMatches(mapContent)) {
    final scaleName = scaleMatch.group(1)!;
    final colorList = scaleMatch.group(2)!;

    // Extract P3 color strings
    final colorRegex = RegExp(r"'color\(display-p3[^']+\)'");
    final colors = colorRegex
        .allMatches(colorList)
        .map((m) => m.group(0)!.replaceAll("'", ''))
        .toList();

    if (colors.length == 12) {
      scales[scaleName] = colors;
    }
  }

  return scales;
}

/// Convert P3 color string to Color value (ARGB format)
int _p3ToColorValue(String p3String) {
  final regex = RegExp(r'color\(display-p3\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)\)');
  final match = regex.firstMatch(p3String);

  if (match == null || match.groupCount != 3) {
    throw ArgumentError('Invalid P3 color string: $p3String');
  }

  final r = double.parse(match.group(1)!);
  final g = double.parse(match.group(2)!);
  final b = double.parse(match.group(3)!);

  final rInt = (r * 255).round().clamp(0, 255);
  final gInt = (g * 255).round().clamp(0, 255);
  final bInt = (b * 255).round().clamp(0, 255);

  // Return ARGB format: 0xFFRRGGBB
  return 0xFF000000 | (rInt << 16) | (gInt << 8) | bInt;
}

/// Generate the constants file content
String _generateConstantsFile(
  Map<String, List<String>> lightScales,
  Map<String, List<String>> darkScales,
) {
  final buffer = StringBuffer();

  buffer.writeln('/// Radix color constants generated from P3 color scales');
  buffer.writeln('///');
  buffer.writeln(
    '/// This file is auto-generated by scripts/generate_radix_colors.dart',
  );
  buffer.writeln(
    '/// Do not edit manually. Regenerate when P3 scales are updated.',
  );
  buffer.writeln('');
  buffer.writeln('import \'package:flutter/material.dart\';');
  buffer.writeln('');
  buffer.writeln('/// Radix color constants for IDE color previews');
  buffer.writeln('///');
  buffer.writeln(
    '/// These const Color values enable IDE color previews like Material colors.',
  );
  buffer.writeln('class RadixColorConstants {');
  buffer.writeln('  RadixColorConstants._();');
  buffer.writeln('');
  buffer.writeln('  static const LightColors light = LightColors();');
  buffer.writeln('  static const DarkColors dark = DarkColors();');
  buffer.writeln('}');
  buffer.writeln('');

  // Generate direct const Color properties for each step (for autocomplete)
  buffer.writeln('/// Direct const Color properties for IDE autocomplete');
  buffer.writeln('/// Usage: RadixColors.blue9, RadixColors.darkGray1, etc.');
  buffer.writeln('class RadixColorSteps {');
  buffer.writeln('  RadixColorSteps._();');
  buffer.writeln('');

  // Generate light step properties
  for (final entry in lightScales.entries) {
    final scaleName = entry.key;
    final colorValues = entry.value.map(_p3ToColorValue).toList();
    final capitalizedName = scaleName[0].toUpperCase() + scaleName.substring(1);

    for (int i = 0; i < 12; i++) {
      final stepNum = i + 1;
      final value = colorValues[i];
      buffer.writeln('  /// $scaleName step $stepNum (light mode)');
      buffer.writeln(
        '  static const Color $scaleName$stepNum = Color(0x${value.toRadixString(16).padLeft(8, '0')});',
      );
      buffer.writeln('');
    }
  }

  // Generate dark step properties
  for (final entry in darkScales.entries) {
    final scaleName = entry.key;
    final colorValues = entry.value.map(_p3ToColorValue).toList();

    for (int i = 0; i < 12; i++) {
      final stepNum = i + 1;
      final value = colorValues[i];
      buffer.writeln('  /// $scaleName step $stepNum (dark mode)');
      buffer.writeln(
        '  static const Color dark${scaleName[0].toUpperCase()}${scaleName.substring(1)}$stepNum = Color(0x${value.toRadixString(16).padLeft(8, '0')});',
      );
      buffer.writeln('');
    }
  }

  buffer.writeln('}');
  buffer.writeln('');

  // Generate light colors class
  buffer.writeln('class LightColors {');
  buffer.writeln('  const LightColors();');
  buffer.writeln('');

  for (final entry in lightScales.entries) {
    final scaleName = entry.key;
    final colorValues = entry.value.map(_p3ToColorValue).toList();

    buffer.writeln('  /// $scaleName color scale (light mode)');
    buffer.write('  static const List<Color> $scaleName = [');
    for (int i = 0; i < colorValues.length; i++) {
      final value = colorValues[i];
      buffer.write('Color(0x${value.toRadixString(16).padLeft(8, '0')})');
      if (i < colorValues.length - 1) buffer.write(', ');
    }
    buffer.writeln('];');
    buffer.writeln('');
  }

  buffer.writeln('}');
  buffer.writeln('');

  // Generate dark colors class
  buffer.writeln('class DarkColors {');
  buffer.writeln('  const DarkColors();');
  buffer.writeln('');

  for (final entry in darkScales.entries) {
    final scaleName = entry.key;
    final colorValues = entry.value.map(_p3ToColorValue).toList();

    buffer.writeln('  /// $scaleName color scale (dark mode)');
    buffer.write('  static const List<Color> $scaleName = [');
    for (int i = 0; i < colorValues.length; i++) {
      final value = colorValues[i];
      buffer.write('Color(0x${value.toRadixString(16).padLeft(8, '0')})');
      if (i < colorValues.length - 1) buffer.write(', ');
    }
    buffer.writeln('];');
    buffer.writeln('');
  }

  buffer.writeln('}');

  return buffer.toString();
}

/// Insert step properties directly into RadixColors class
void _insertStepPropertiesIntoRadixColors(
  Map<String, List<String>> lightScales,
) {
  final radixColorsFile = File(
    path.join(path.current, 'lib', 'theme', 'radix_colors.dart'),
  );

  if (!radixColorsFile.existsSync()) {
    print('Error: radix_colors.dart not found');
    return;
  }

  final content = radixColorsFile.readAsStringSync();

  // Generate the step properties code
  final buffer = StringBuffer();
  for (final entry in lightScales.entries) {
    final scaleName = entry.key;
    final colorValues = entry.value.map(_p3ToColorValue).toList();

    for (int i = 0; i < 12; i++) {
      final stepNum = i + 1;
      final value = colorValues[i];
      final isBase = stepNum == 9;
      final comment = isBase ? ' - base color' : '';

      buffer.writeln(
        '  /// ${scaleName[0].toUpperCase()}${scaleName.substring(1)} step $stepNum (light)$comment',
      );
      buffer.writeln(
        '  static const Color $scaleName$stepNum = RadixColorSteps.$scaleName$stepNum;',
      );
      buffer.writeln('');
    }
  }

  final stepPropertiesCode = buffer.toString();

  // Replace content between BEGIN and END markers
  final beginMarker = '// BEGIN GENERATED STEP PROPERTIES';
  final endMarker = '// END GENERATED STEP PROPERTIES';

  final beginRegex = RegExp(RegExp.escape(beginMarker));
  final endRegex = RegExp(RegExp.escape(endMarker));

  final beginMatch = beginRegex.firstMatch(content);
  final endMatch = endRegex.firstMatch(content);

  if (beginMatch == null || endMatch == null) {
    print('Warning: Could not find BEGIN/END markers in radix_colors.dart');
    print('Step properties were not inserted. Please add markers manually.');
    return;
  }

  final before = content.substring(0, beginMatch.end);
  final after = content.substring(endMatch.start);

  final newContent = '$before\n$stepPropertiesCode$after';

  radixColorsFile.writeAsStringSync(newContent);
  print('Inserted step properties into RadixColors class');
}

/// Insert dark step properties directly into RadixDarkColors class
void _insertDarkStepPropertiesIntoRadixColorsDark(
  Map<String, List<String>> darkScales,
) {
  final radixColorsFile = File(
    path.join(path.current, 'lib', 'theme', 'radix_colors.dart'),
  );

  if (!radixColorsFile.existsSync()) {
    print('Error: radix_colors.dart not found');
    return;
  }

  final content = radixColorsFile.readAsStringSync();

  // Generate the dark step properties code
  final buffer = StringBuffer();
  for (final entry in darkScales.entries) {
    final scaleName = entry.key;

    for (int i = 0; i < 12; i++) {
      final stepNum = i + 1;
      final isBase = stepNum == 9;
      final comment = isBase ? ' - base color' : '';

      buffer.writeln(
        '  /// ${scaleName[0].toUpperCase()}${scaleName.substring(1)} step $stepNum (dark)$comment',
      );
      buffer.writeln(
        '  static const Color $scaleName$stepNum = RadixColorSteps.dark${scaleName[0].toUpperCase()}${scaleName.substring(1)}$stepNum;',
      );
      buffer.writeln('');
    }
  }

  final stepPropertiesCode = buffer.toString();

  // Find and replace content between BEGIN and END markers in RadixDarkColors class
  final darkBeginMarker = '// BEGIN GENERATED DARK STEP PROPERTIES';
  final darkEndMarker = '// END GENERATED DARK STEP PROPERTIES';

  final beginRegex = RegExp(RegExp.escape(darkBeginMarker));
  final endRegex = RegExp(RegExp.escape(darkEndMarker));

  final beginMatch = beginRegex.firstMatch(content);
  final endMatch = endRegex.firstMatch(content);

  if (beginMatch == null || endMatch == null) {
    print(
      'Warning: Could not find BEGIN/END markers for dark properties in radix_colors.dart',
    );
    print('Dark step properties were not inserted.');
    return;
  }

  final before = content.substring(0, beginMatch.end);
  final after = content.substring(endMatch.start);

  final newContent = '$before\n$stepPropertiesCode$after';

  radixColorsFile.writeAsStringSync(newContent);
  print('Inserted dark step properties into RadixDarkColors class');
}

/// Insert context-aware step properties into RadixColorScheme class
void _insertContextStepPropertiesIntoRadixColorsContext(
  Map<String, List<String>> lightScales,
  Map<String, List<String>> darkScales,
) {
  final radixColorsFile = File(
    path.join(path.current, 'lib', 'theme', 'radix_colors.dart'),
  );

  if (!radixColorsFile.existsSync()) {
    print('Error: radix_colors.dart not found');
    return;
  }

  final content = radixColorsFile.readAsStringSync();

  // Generate the context-aware step properties code
  final buffer = StringBuffer();
  for (final entry in lightScales.entries) {
    final scaleName = entry.key;
    final capitalizedName = scaleName[0].toUpperCase() + scaleName.substring(1);

    for (int i = 0; i < 12; i++) {
      final stepNum = i + 1;
      final isBase = stepNum == 9;
      final comment = isBase ? ' - base color' : '';

      buffer.writeln(
        '  /// ${scaleName[0].toUpperCase()}${scaleName.substring(1)} step $stepNum (context-aware)$comment',
      );
      buffer.writeln(
        '  Color get $scaleName$stepNum => _isLight ? RadixColorSteps.$scaleName$stepNum : RadixColorSteps.dark$capitalizedName$stepNum;',
      );
      buffer.writeln('');
    }
  }

  final stepPropertiesCode = buffer.toString();

  // Find and replace content between BEGIN and END markers
  final beginMarker = '// BEGIN GENERATED CONTEXT STEP PROPERTIES';
  final endMarker = '// END GENERATED CONTEXT STEP PROPERTIES';

  final beginRegex = RegExp(RegExp.escape(beginMarker));
  final endRegex = RegExp(RegExp.escape(endMarker));

  final beginMatch = beginRegex.firstMatch(content);
  final endMatch = endRegex.firstMatch(content);

  if (beginMatch == null || endMatch == null) {
    print(
      'Warning: Could not find BEGIN/END markers for context properties in radix_colors.dart',
    );
    print('Context step properties were not inserted.');
    return;
  }

  final before = content.substring(0, beginMatch.end);
  final after = content.substring(endMatch.start);

  final newContent = '$before\n$stepPropertiesCode$after';

  radixColorsFile.writeAsStringSync(newContent);
  print('Inserted context-aware step properties into RadixColorScheme class');
}
