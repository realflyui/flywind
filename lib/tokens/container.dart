// GENERATED FILE - DO NOT EDIT MANUALLY
// This file was generated by generate.dart
// To regenerate, run: dart generate/generate.dart
//

import '../src/theme.dart';

/// Container width values
class FlyContainerToken implements FlyToken<double> {
  const FlyContainerToken({
    required this.xs3,
    required this.xs2,
    required this.xs,
    required this.sm,
    required this.md,
    required this.lg,
    required this.xl,
    required this.xl2,
    required this.xl3,
    required this.xl4,
    required this.xl5,
    required this.xl6,
    required this.xl7,
    this.extras = const {},
  });

  /// 3xs Container width values
  final double xs3;
  /// 2xs Container width values
  final double xs2;
  /// xs Container width values
  final double xs;
  /// sm Container width values
  final double sm;
  /// md Container width values
  final double md;
  /// lg Container width values
  final double lg;
  /// xl Container width values
  final double xl;
  /// 2xl Container width values
  final double xl2;
  /// 3xl Container width values
  final double xl3;
  /// 4xl Container width values
  final double xl4;
  /// 5xl Container width values
  final double xl5;
  /// 6xl Container width values
  final double xl6;
  /// 7xl Container width values
  final double xl7;

  /// Additional custom values
  final Map<String, double> extras;

  /// All values in a single map for easier iteration
  Map<String, double> get _allValues => {
    'xs3': xs3,
    'xs2': xs2,
    'xs': xs,
    'sm': sm,
    'md': md,
    'lg': lg,
    'xl': xl,
    'xl2': xl2,
    'xl3': xl3,
    'xl4': xl4,
    'xl5': xl5,
    'xl6': xl6,
    'xl7': xl7,
    ...extras,
  };

  /// Access value by key (canonical or extra)
  @override
  double? operator[](String key) => _allValues[key];

  /// Get all available keys (canonical + extras)
  @override
  Iterable<String> get keys => _allValues.keys;

  /// Put a new value for the given key
  @override
  FlyContainerToken put(String key, double value) {
    switch (key) {
      case 'xs3':
        return copyWith(xs3: value);
      case 'xs2':
        return copyWith(xs2: value);
      case 'xs':
        return copyWith(xs: value);
      case 'sm':
        return copyWith(sm: value);
      case 'md':
        return copyWith(md: value);
      case 'lg':
        return copyWith(lg: value);
      case 'xl':
        return copyWith(xl: value);
      case 'xl2':
        return copyWith(xl2: value);
      case 'xl3':
        return copyWith(xl3: value);
      case 'xl4':
        return copyWith(xl4: value);
      case 'xl5':
        return copyWith(xl5: value);
      case 'xl6':
        return copyWith(xl6: value);
      case 'xl7':
        return copyWith(xl7: value);
      default:
        final newExtras = Map<String, double>.from(extras);
        newExtras[key] = value;
        return copyWith(extras: newExtras);
    }
  }

  /// Merge another token into this one (right side wins)
  @override
  FlyContainerToken merge(FlyToken<double> other) {
    if (other is! FlyContainerToken) return this;
    
    return copyWith(
      xs3: other.xs3,
      xs2: other.xs2,
      xs: other.xs,
      sm: other.sm,
      md: other.md,
      lg: other.lg,
      xl: other.xl,
      xl2: other.xl2,
      xl3: other.xl3,
      xl4: other.xl4,
      xl5: other.xl5,
      xl6: other.xl6,
      xl7: other.xl7,
      extras: {...extras, ...other.extras},
    );
  }

  /// Create a copy with updated values
  FlyContainerToken copyWith({
    double? xs3,
    double? xs2,
    double? xs,
    double? sm,
    double? md,
    double? lg,
    double? xl,
    double? xl2,
    double? xl3,
    double? xl4,
    double? xl5,
    double? xl6,
    double? xl7,
    Map<String, double>? extras,
  }) {
    return FlyContainerToken(
      xs3: xs3 ?? this.xs3,
      xs2: xs2 ?? this.xs2,
      xs: xs ?? this.xs,
      sm: sm ?? this.sm,
      md: md ?? this.md,
      lg: lg ?? this.lg,
      xl: xl ?? this.xl,
      xl2: xl2 ?? this.xl2,
      xl3: xl3 ?? this.xl3,
      xl4: xl4 ?? this.xl4,
      xl5: xl5 ?? this.xl5,
      xl6: xl6 ?? this.xl6,
      xl7: xl7 ?? this.xl7,
      extras: extras ?? this.extras,
    );
  }

  /// Linear interpolation between two tokens
  FlyContainerToken lerp(FlyContainerToken other, double t) {
    final result = <String, double>{};
    final allKeys = {..._allValues.keys, ...other._allValues.keys};
    
    for (final key in allKeys) {
      final valueA = _allValues[key];
      final valueB = other._allValues[key];
      final numA = valueA ?? 0.0;
      final numB = valueB ?? 0.0;
      result[key] = numA + (numB - numA) * t;
    }
    
    return FlyContainerToken(
      xs3: result['xs3']!,
      xs2: result['xs2']!,
      xs: result['xs']!,
      sm: result['sm']!,
      md: result['md']!,
      lg: result['lg']!,
      xl: result['xl']!,
      xl2: result['xl2']!,
      xl3: result['xl3']!,
      xl4: result['xl4']!,
      xl5: result['xl5']!,
      xl6: result['xl6']!,
      xl7: result['xl7']!,
      extras: Map.fromEntries(result.entries.where((e) => !['xs3', 'xs2', 'xs', 'sm', 'md', 'lg', 'xl', 'xl2', 'xl3', 'xl4', 'xl5', 'xl6', 'xl7'].contains(e.key))),
    );
  }

  /// Create default values
  static FlyContainerToken defaultContainer() {
    return const FlyContainerToken(
      xs3: 256.0,
      xs2: 288.0,
      xs: 320.0,
      sm: 384.0,
      md: 448.0,
      lg: 512.0,
      xl: 576.0,
      xl2: 672.0,
      xl3: 768.0,
      xl4: 896.0,
      xl5: 1024.0,
      xl6: 1152.0,
      xl7: 1280.0,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is FlyContainerToken && _allValues.toString() == other._allValues.toString();
  }

  @override
  int get hashCode => _allValues.hashCode;
}
