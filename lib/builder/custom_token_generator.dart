import 'dart:async';

import 'package:build/build.dart';
import 'package:yaml/yaml.dart';
import 'converters/color_converter.dart';

/// Custom token builder that generates custom token classes and extensions from fly-config.yaml
class CustomTokenBuilder implements Builder {
  @override
  Map<String, List<String>> get buildExtensions => {
    'lib/flywind/flywind.yaml': [
      'lib/flywind/config/config.dart',
      'lib/flywind/config/colors.dart',
      'lib/flywind/config/spacing.dart',
      'lib/flywind/config/radius.dart',
      'lib/flywind/config/breakpoint.dart',
      'lib/flywind/config/container.dart',
      'lib/flywind/config/text.dart',
      'lib/flywind/config/text_line_height.dart',
      'lib/flywind/config/font_weight.dart',
      'lib/flywind/config/tracking.dart',
      'lib/flywind/config/blur.dart',
      'lib/flywind/config/perspective.dart',
      'lib/flywind/config/leading.dart',
    ],
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    // Get the input asset (lib/flywind/flywind.yaml)
    final inputId = buildStep.inputId;
    log.info('Processing custom token config: ${inputId.path}');

    if (!inputId.path.endsWith('flywind.yaml')) {
      log.warning('Expected flywind.yaml input, got: ${inputId.path}');
      return;
    }

    final configContent = await buildStep.readAsString(inputId);
    log.info('Found flywind.yaml, generating custom tokens...');

    // Parse YAML configuration
    final config = loadYaml(configContent) as Map<dynamic, dynamic>;

    // Generate custom token classes
    if (config['extend']?['colors'] != null) {
      await _generateCustomColors(buildStep, config);
    }

    if (config['extend']?['spacing'] != null) {
      await _generateCustomSpacing(buildStep, config);
    }

    if (config['extend']?['radius'] != null) {
      await _generateCustomRadius(buildStep, config);
    }

    if (config['extend']?['breakpoint'] != null) {
      await _generateCustomBreakpoint(buildStep, config);
    }

    if (config['extend']?['container'] != null) {
      await _generateCustomContainer(buildStep, config);
    }

    if (config['extend']?['text'] != null) {
      await _generateCustomText(buildStep, config);
    }

    if (config['extend']?['text_line_height'] != null) {
      await _generateCustomTextLineHeight(buildStep, config);
    }

    if (config['extend']?['font_weight'] != null) {
      await _generateCustomFontWeight(buildStep, config);
    }

    if (config['extend']?['tracking'] != null) {
      await _generateCustomTracking(buildStep, config);
    }

    if (config['extend']?['blur'] != null) {
      await _generateCustomBlur(buildStep, config);
    }

    if (config['extend']?['perspective'] != null) {
      await _generateCustomPerspective(buildStep, config);
    }

    if (config['extend']?['leading'] != null) {
      await _generateCustomLeading(buildStep, config);
    }

    // Generate the main custom tokens file
    await _generateCustomTokensFile(buildStep, config);

    log.info('Custom token generation completed!');
  }

  /// Generate custom colors class
  Future<void> _generateCustomColors(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final colors = Map<String, dynamic>.from(config['extend']['colors']);
    if (colors.isEmpty) return;

    log.info('Generating custom colors...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln("import 'package:flywind/tokens/color.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom colors that provide dot notation access to custom color values',
    );
    buffer.writeln('class CustomColors {');
    buffer.writeln('  const CustomColors._();');
    buffer.writeln();

    // Generate custom color properties
    for (final entry in colors.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterColor = _convertColorValue(value);

      buffer.writeln('  /// Custom color: $key');
      buffer.writeln('  static const Color $fieldName = $flutterColor;');
    }
    buffer.writeln();

    // Generate default method that creates a FlyColorToken with custom extras
    buffer.writeln('  /// Create default custom colors as FlyColorToken');
    buffer.writeln('  static FlyColorToken defaultColors() {');
    buffer.writeln('    return FlyColorToken.defaultColor().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in colors.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterColor = _convertColorValue(value);
      buffer.writeln("        '$key': $flutterColor,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlyColorToken to provide dot notation access',
    );
    buffer.writeln('extension FlyColorTokenExtensions on FlyColorToken {');

    for (final entry in colors.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterColor = _convertColorValue(value);

      buffer.writeln('  /// Custom color: $key');
      buffer.writeln(
        '  Color get $fieldName => extras[\'$key\'] ?? $flutterColor;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/colors.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom colors: ${colors.keys.join(', ')}');
  }

  /// Generate custom spacing class
  Future<void> _generateCustomSpacing(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final spacing = Map<String, dynamic>.from(config['extend']['spacing']);
    if (spacing.isEmpty) return;

    log.info('Generating custom spacing...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flywind/tokens/spacing.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom spacing that provide dot notation access to custom spacing values',
    );
    buffer.writeln('class CustomSpacing {');
    buffer.writeln('  const CustomSpacing._();');
    buffer.writeln();

    // Generate custom spacing properties
    for (final entry in spacing.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertSpacingValue(value);

      buffer.writeln('  /// Custom spacing: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();

    // Generate default method that creates a FlySpacingToken with custom extras
    buffer.writeln('  /// Create default custom spacing as FlySpacingToken');
    buffer.writeln('  static FlySpacingToken defaultSpacing() {');
    buffer.writeln('    return FlySpacingToken.defaultSpacing().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in spacing.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertSpacingValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlySpacingToken to provide dot notation access',
    );
    buffer.writeln('extension FlySpacingTokenExtensions on FlySpacingToken {');

    for (final entry in spacing.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertSpacingValue(value);

      buffer.writeln('  /// Custom spacing: $key');
      buffer.writeln(
        '  double get $fieldName => extras[\'$key\'] ?? $flutterValue;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/spacing.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom spacing: ${spacing.keys.join(', ')}');
  }

  /// Generate custom radius class
  Future<void> _generateCustomRadius(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final radius = Map<String, dynamic>.from(config['extend']['radius']);
    if (radius.isEmpty) return;

    log.info('Generating custom radius...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flywind/tokens/radius.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom radius that provide dot notation access to custom radius values',
    );
    buffer.writeln('class CustomRadius {');
    buffer.writeln('  const CustomRadius._();');
    buffer.writeln();

    // Generate custom radius properties
    for (final entry in radius.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertRadiusValue(value);

      buffer.writeln('  /// Custom radius: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();

    // Generate default method that creates a FlyRadiusToken with custom extras
    buffer.writeln('  /// Create default custom radius as FlyRadiusToken');
    buffer.writeln('  static FlyRadiusToken defaultRadius() {');
    buffer.writeln('    return FlyRadiusToken.defaultRadius().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in radius.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertRadiusValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlyRadiusToken to provide dot notation access',
    );
    buffer.writeln('extension FlyRadiusTokenExtensions on FlyRadiusToken {');

    for (final entry in radius.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertRadiusValue(value);

      buffer.writeln('  /// Custom radius: $key');
      buffer.writeln(
        '  double get $fieldName => extras[\'$key\'] ?? $flutterValue;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/radius.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom radius: ${radius.keys.join(', ')}');
  }

  /// Generate custom breakpoint class
  Future<void> _generateCustomBreakpoint(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final breakpoint = Map<String, dynamic>.from(
      config['extend']['breakpoint'],
    );
    if (breakpoint.isEmpty) return;

    log.info('Generating custom breakpoint...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flywind/tokens/breakpoint.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom breakpoint that provide dot notation access to custom breakpoint values',
    );
    buffer.writeln('class CustomBreakpoint {');
    buffer.writeln('  const CustomBreakpoint._();');
    buffer.writeln();

    // Generate custom breakpoint properties
    for (final entry in breakpoint.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom breakpoint: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();

    // Generate default method that creates a FlyBreakpointToken with custom extras
    buffer.writeln(
      '  /// Create default custom breakpoint as FlyBreakpointToken',
    );
    buffer.writeln('  static FlyBreakpointToken defaultBreakpoint() {');
    buffer.writeln(
      '    return FlyBreakpointToken.defaultBreakpoint().copyWith(',
    );
    buffer.writeln('      extras: {');
    for (final entry in breakpoint.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlyBreakpointToken to provide dot notation access',
    );
    buffer.writeln(
      'extension FlyBreakpointTokenExtensions on FlyBreakpointToken {',
    );

    for (final entry in breakpoint.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom breakpoint: $key');
      buffer.writeln(
        '  double get $fieldName => extras[\'$key\'] ?? $flutterValue;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/breakpoint.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom breakpoint: ${breakpoint.keys.join(', ')}');
  }

  /// Generate custom container class
  Future<void> _generateCustomContainer(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final container = Map<String, dynamic>.from(config['extend']['container']);
    if (container.isEmpty) return;

    log.info('Generating custom container...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flywind/tokens/container.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom container that provide dot notation access to custom container values',
    );
    buffer.writeln('class CustomContainer {');
    buffer.writeln('  const CustomContainer._();');
    buffer.writeln();

    // Generate custom container properties
    for (final entry in container.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom container: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();

    // Generate default method that creates a FlyContainerToken with custom extras
    buffer.writeln(
      '  /// Create default custom container as FlyContainerToken',
    );
    buffer.writeln('  static FlyContainerToken defaultContainer() {');
    buffer.writeln('    return FlyContainerToken.defaultContainer().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in container.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlyContainerToken to provide dot notation access',
    );
    buffer.writeln(
      'extension FlyContainerTokenExtensions on FlyContainerToken {',
    );

    for (final entry in container.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom container: $key');
      buffer.writeln(
        '  double get $fieldName => extras[\'$key\'] ?? $flutterValue;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/container.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom container: ${container.keys.join(', ')}');
  }

  /// Generate custom text class
  Future<void> _generateCustomText(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final text = Map<String, dynamic>.from(config['extend']['text']);
    if (text.isEmpty) return;

    log.info('Generating custom text...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flywind/tokens/text.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom text that provide dot notation access to custom text values',
    );
    buffer.writeln('class CustomText {');
    buffer.writeln('  const CustomText._();');
    buffer.writeln();

    // Generate custom text properties
    for (final entry in text.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom text: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();

    // Generate default method that creates a FlyTextToken with custom extras
    buffer.writeln('  /// Create default custom text as FlyTextToken');
    buffer.writeln('  static FlyTextToken defaultText() {');
    buffer.writeln('    return FlyTextToken.defaultText().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in text.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlyTextToken to provide dot notation access',
    );
    buffer.writeln('extension FlyTextTokenExtensions on FlyTextToken {');

    for (final entry in text.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom text: $key');
      buffer.writeln(
        '  double get $fieldName => extras[\'$key\'] ?? $flutterValue;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/text.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom text: ${text.keys.join(', ')}');
  }

  /// Generate custom text line height class
  Future<void> _generateCustomTextLineHeight(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final textLineHeight = Map<String, dynamic>.from(
      config['extend']['text_line_height'],
    );
    if (textLineHeight.isEmpty) return;

    log.info('Generating custom text line height...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flywind/tokens/text_line_height.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom text line height that provide dot notation access to custom text line height values',
    );
    buffer.writeln('class CustomTextLineHeight {');
    buffer.writeln('  const CustomTextLineHeight._();');
    buffer.writeln();

    // Generate custom text line height properties
    for (final entry in textLineHeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom text line height: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();

    // Generate default method that creates a FlyTextLineHeightToken with custom extras
    buffer.writeln(
      '  /// Create default custom text line height as FlyTextLineHeightToken',
    );
    buffer.writeln('  static FlyTextLineHeightToken defaultTextLineHeight() {');
    buffer.writeln(
      '    return FlyTextLineHeightToken.defaultTextLineHeight().copyWith(',
    );
    buffer.writeln('      extras: {');
    for (final entry in textLineHeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlyTextLineHeightToken to provide dot notation access',
    );
    buffer.writeln(
      'extension FlyTextLineHeightTokenExtensions on FlyTextLineHeightToken {',
    );

    for (final entry in textLineHeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom text line height: $key');
      buffer.writeln(
        '  double get $fieldName => extras[\'$key\'] ?? $flutterValue;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/text_line_height.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom text line height: ${textLineHeight.keys.join(', ')}');
  }

  /// Generate custom font weight class
  Future<void> _generateCustomFontWeight(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final fontWeight = Map<String, dynamic>.from(
      config['extend']['font_weight'],
    );
    if (fontWeight.isEmpty) return;

    log.info('Generating custom font weight...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln("import 'package:flywind/tokens/font_weight.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom font weight that provide dot notation access to custom font weight values',
    );
    buffer.writeln('class CustomFontWeight {');
    buffer.writeln('  const CustomFontWeight._();');
    buffer.writeln();

    // Generate custom font weight properties
    for (final entry in fontWeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertFontWeightValue(value);

      buffer.writeln('  /// Custom font weight: $key');
      buffer.writeln('  static const FontWeight $fieldName = $flutterValue;');
    }
    buffer.writeln();

    // Generate default method that creates a FlyFontWeightToken with custom extras
    buffer.writeln(
      '  /// Create default custom font weight as FlyFontWeightToken',
    );
    buffer.writeln('  static FlyFontWeightToken defaultFontWeight() {');
    buffer.writeln(
      '    return FlyFontWeightToken.defaultFontWeight().copyWith(',
    );
    buffer.writeln('      extras: {');
    for (final entry in fontWeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertFontWeightValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlyFontWeightToken to provide dot notation access',
    );
    buffer.writeln(
      'extension FlyFontWeightTokenExtensions on FlyFontWeightToken {',
    );

    for (final entry in fontWeight.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertFontWeightValue(value);

      buffer.writeln('  /// Custom font weight: $key');
      buffer.writeln(
        '  FontWeight get $fieldName => extras[\'$key\'] ?? $flutterValue;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/font_weight.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom font weight: ${fontWeight.keys.join(', ')}');
  }

  /// Generate custom tracking class
  Future<void> _generateCustomTracking(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final tracking = Map<String, dynamic>.from(config['extend']['tracking']);
    if (tracking.isEmpty) return;

    log.info('Generating custom tracking...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flywind/tokens/tracking.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom tracking that provide dot notation access to custom tracking values',
    );
    buffer.writeln('class CustomTracking {');
    buffer.writeln('  const CustomTracking._();');
    buffer.writeln();

    // Generate custom tracking properties
    for (final entry in tracking.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom tracking: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();

    // Generate default method that creates a FlyTrackingToken with custom extras
    buffer.writeln('  /// Create default custom tracking as FlyTrackingToken');
    buffer.writeln('  static FlyTrackingToken defaultTracking() {');
    buffer.writeln('    return FlyTrackingToken.defaultTracking().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in tracking.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlyTrackingToken to provide dot notation access',
    );
    buffer.writeln(
      'extension FlyTrackingTokenExtensions on FlyTrackingToken {',
    );

    for (final entry in tracking.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom tracking: $key');
      buffer.writeln(
        '  double get $fieldName => extras[\'$key\'] ?? $flutterValue;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/tracking.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom tracking: ${tracking.keys.join(', ')}');
  }

  /// Generate custom blur class
  Future<void> _generateCustomBlur(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final blur = Map<String, dynamic>.from(config['extend']['blur']);
    if (blur.isEmpty) return;

    log.info('Generating custom blur...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flywind/tokens/blur.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom blur that provide dot notation access to custom blur values',
    );
    buffer.writeln('class CustomBlur {');
    buffer.writeln('  const CustomBlur._();');
    buffer.writeln();

    // Generate custom blur properties
    for (final entry in blur.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom blur: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();

    // Generate default method that creates a FlyBlurToken with custom extras
    buffer.writeln('  /// Create default custom blur as FlyBlurToken');
    buffer.writeln('  static FlyBlurToken defaultBlur() {');
    buffer.writeln('    return FlyBlurToken.defaultBlur().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in blur.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlyBlurToken to provide dot notation access',
    );
    buffer.writeln('extension FlyBlurTokenExtensions on FlyBlurToken {');

    for (final entry in blur.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom blur: $key');
      buffer.writeln(
        '  double get $fieldName => extras[\'$key\'] ?? $flutterValue;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/blur.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom blur: ${blur.keys.join(', ')}');
  }

  /// Generate custom perspective class
  Future<void> _generateCustomPerspective(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final perspective = Map<String, dynamic>.from(
      config['extend']['perspective'],
    );
    if (perspective.isEmpty) return;

    log.info('Generating custom perspective...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flywind/tokens/perspective.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom perspective that provide dot notation access to custom perspective values',
    );
    buffer.writeln('class CustomPerspective {');
    buffer.writeln('  const CustomPerspective._();');
    buffer.writeln();

    // Generate custom perspective properties
    for (final entry in perspective.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom perspective: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();

    // Generate default method that creates a FlyPerspectiveToken with custom extras
    buffer.writeln(
      '  /// Create default custom perspective as FlyPerspectiveToken',
    );
    buffer.writeln('  static FlyPerspectiveToken defaultPerspective() {');
    buffer.writeln(
      '    return FlyPerspectiveToken.defaultPerspective().copyWith(',
    );
    buffer.writeln('      extras: {');
    for (final entry in perspective.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlyPerspectiveToken to provide dot notation access',
    );
    buffer.writeln(
      'extension FlyPerspectiveTokenExtensions on FlyPerspectiveToken {',
    );

    for (final entry in perspective.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom perspective: $key');
      buffer.writeln(
        '  double get $fieldName => extras[\'$key\'] ?? $flutterValue;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/perspective.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom perspective: ${perspective.keys.join(', ')}');
  }

  /// Generate custom leading class
  Future<void> _generateCustomLeading(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final leading = Map<String, dynamic>.from(config['extend']['leading']);
    if (leading.isEmpty) return;

    log.info('Generating custom leading...');

    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flywind/tokens/leading.dart';");
    buffer.writeln();

    // Add class documentation
    buffer.writeln(
      '/// Custom leading that provide dot notation access to custom leading values',
    );
    buffer.writeln('class CustomLeading {');
    buffer.writeln('  const CustomLeading._();');
    buffer.writeln();

    // Generate custom leading properties
    for (final entry in leading.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom leading: $key');
      buffer.writeln('  static const double $fieldName = $flutterValue;');
    }
    buffer.writeln();

    // Generate default method that creates a FlyLeadingToken with custom extras
    buffer.writeln('  /// Create default custom leading as FlyLeadingToken');
    buffer.writeln('  static FlyLeadingToken defaultLeading() {');
    buffer.writeln('    return FlyLeadingToken.defaultLeading().copyWith(');
    buffer.writeln('      extras: {');
    for (final entry in leading.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final flutterValue = _convertDoubleValue(value);
      buffer.writeln("        '$key': $flutterValue,");
    }
    buffer.writeln('      },');
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Add extension methods for dot notation
    buffer.writeln(
      '/// Extension methods for FlyLeadingToken to provide dot notation access',
    );
    buffer.writeln('extension FlyLeadingTokenExtensions on FlyLeadingToken {');

    for (final entry in leading.entries) {
      final key = entry.key;
      final value = entry.value.toString();
      final fieldName = _getFieldName(key);
      final flutterValue = _convertDoubleValue(value);

      buffer.writeln('  /// Custom leading: $key');
      buffer.writeln(
        '  double get $fieldName => extras[\'$key\'] ?? $flutterValue;',
      );
    }

    buffer.writeln('}');

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/leading.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
    log.info('Custom leading: ${leading.keys.join(', ')}');
  }

  /// Generate the main custom tokens file
  Future<void> _generateCustomTokensFile(
    BuildStep buildStep,
    Map<dynamic, dynamic> config,
  ) async {
    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln('// To regenerate, run: dart run build_runner build');
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    buffer.writeln();

    // Add exports
    if (config['extend']?['colors'] != null) {
      buffer.writeln("export 'colors.dart';");
    }
    if (config['extend']?['spacing'] != null) {
      buffer.writeln("export 'spacing.dart';");
    }
    if (config['extend']?['radius'] != null) {
      buffer.writeln("export 'radius.dart';");
    }
    if (config['extend']?['breakpoint'] != null) {
      buffer.writeln("export 'breakpoint.dart';");
    }
    if (config['extend']?['container'] != null) {
      buffer.writeln("export 'container.dart';");
    }
    if (config['extend']?['text'] != null) {
      buffer.writeln("export 'text.dart';");
    }
    if (config['extend']?['text_line_height'] != null) {
      buffer.writeln("export 'text_line_height.dart';");
    }
    if (config['extend']?['font_weight'] != null) {
      buffer.writeln("export 'font_weight.dart';");
    }
    if (config['extend']?['tracking'] != null) {
      buffer.writeln("export 'tracking.dart';");
    }
    if (config['extend']?['blur'] != null) {
      buffer.writeln("export 'blur.dart';");
    }
    if (config['extend']?['perspective'] != null) {
      buffer.writeln("export 'perspective.dart';");
    }
    if (config['extend']?['leading'] != null) {
      buffer.writeln("export 'leading.dart';");
    }

    // Write the file using BuildStep
    final outputAsset = AssetId(
      buildStep.inputId.package,
      'lib/flywind/config/config.dart',
    );
    await buildStep.writeAsString(outputAsset, buffer.toString());

    log.info('Generated: ${outputAsset.path}');
  }

  /// Convert key to valid Dart field name (camelCase)
  static String _getFieldName(String key) {
    if (key.isEmpty) {
      return 'defaultValue';
    }

    // Handle purely numeric keys (e.g., "4" -> "s4")
    if (RegExp(r'^\d+$').hasMatch(key)) {
      return 's$key';
    }

    // Handle keys that start with numbers (e.g., "2xl" -> "xl2", "3xs" -> "xs3")
    final numberPrefixMatch = RegExp(r'^(\d+)([a-zA-Z]+)$').firstMatch(key);
    if (numberPrefixMatch != null) {
      final number = numberPrefixMatch.group(1)!;
      final letters = numberPrefixMatch.group(2)!;
      return '${letters.toLowerCase()}$number';
    }

    // Convert to camelCase and handle other patterns
    final parts = key.split(RegExp(r'[^a-zA-Z0-9]+'));
    if (parts.isEmpty) return 'value';

    final firstPart = parts[0].toLowerCase();
    final remainingParts = parts.skip(1).map((part) {
      if (part.isEmpty) return '';
      return part[0].toUpperCase() + part.substring(1).toLowerCase();
    });

    return firstPart + remainingParts.join('');
  }

  /// Convert color value to Flutter Color
  String _convertColorValue(String value) {
    if (value.startsWith('#')) {
      return ColorConverter.hexToFlutterColor(value);
    } else {
      return 'const Color(0xFF000000)'; // fallback
    }
  }

  /// Convert spacing value to Flutter double
  String _convertSpacingValue(String value) {
    final doubleValue = double.tryParse(value) ?? 0.0;
    return doubleValue.toString();
  }

  /// Convert radius value to Flutter double
  String _convertRadiusValue(String value) {
    final doubleValue = double.tryParse(value) ?? 0.0;
    return doubleValue.toString();
  }

  /// Convert double value to Flutter double
  String _convertDoubleValue(String value) {
    final doubleValue = double.tryParse(value) ?? 0.0;
    return doubleValue.toString();
  }

  /// Convert font weight value to Flutter FontWeight
  String _convertFontWeightValue(String value) {
    final intValue = int.tryParse(value) ?? 400;

    // Clamp to valid FontWeight values (100-900, in steps of 100)
    final clampedValue = (intValue / 100).round() * 100;
    final validValue = clampedValue.clamp(100, 900);

    return 'FontWeight.w$validValue';
  }
}

/// Builder factory function for the build system
Builder customTokenBuilder(BuilderOptions options) => CustomTokenBuilder();
