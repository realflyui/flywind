import 'dart:async';

import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';
import 'package:yaml/yaml.dart';

/// FlyWind code generator that reads from flywind.yaml configuration
class FlywindGenerator extends Generator {
  @override
  FutureOr<String?> generate(LibraryReader library, BuildStep buildStep) async {
    // Read the flywind.yaml configuration file
    final configAsset = AssetId(buildStep.inputId.package, 'flywind.yaml');

    // Check if the config file exists
    if (!await buildStep.canRead(configAsset)) {
      log.warning('flywind.yaml not found in project root');
      return null;
    }

    final configContent = await buildStep.readAsString(configAsset);

    // Parse YAML configuration
    final config = loadYaml(configContent) as Map<dynamic, dynamic>;

    // Generate the tokens file
    return _generateTokensFile(config);
  }

  /// Generate the main tokens file from configuration
  String _generateTokensFile(Map<dynamic, dynamic> config) {
    final buffer = StringBuffer();

    // Add header
    buffer.writeln('// GENERATED FILE - DO NOT EDIT MANUALLY');
    buffer.writeln('// This file was generated by FlyWind build runner');
    buffer.writeln(
      '// To regenerate, run: flutter packages pub run build_runner build',
    );
    buffer.writeln('//');
    buffer.writeln('// Generated on: ${DateTime.now().toIso8601String()}');
    buffer.writeln();

    // Add imports
    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln("import 'package:flywind/flywind.dart';");
    buffer.writeln();

    // Add main export class
    buffer.writeln('/// Main FlyWind tokens class');
    buffer.writeln('class FlywindTokens {');
    buffer.writeln('  const FlywindTokens._();');
    buffer.writeln();

    // Generate token instances
    final tokens = config['tokens'] as Map<dynamic, dynamic>? ?? {};
    for (final entry in tokens.entries) {
      final tokenName = entry.key as String;
      final tokenConfig = entry.value as Map<dynamic, dynamic>;
      final className = tokenConfig['name'] as String;

      buffer.writeln('  /// $className instance');
      buffer.writeln(
        '  static const $className ${_getFieldName(tokenName)} = $className.default${className.replaceAll('Fly', '')};',
      );
      buffer.writeln();
    }

    buffer.writeln('}');
    buffer.writeln();

    // Generate individual token classes
    for (final entry in tokens.entries) {
      final tokenName = entry.key as String;
      final tokenConfig = entry.value as Map<dynamic, dynamic>;
      buffer.writeln(_generateTokenClass(tokenName, tokenConfig));
      buffer.writeln();
    }

    return buffer.toString();
  }

  /// Generate a single token class
  String _generateTokenClass(String tokenName, Map<dynamic, dynamic> config) {
    final className = config['name'] as String;
    final type = config['type'] as String;
    final description = config['description'] as String? ?? '';
    final values = config['values'] as Map<dynamic, dynamic>? ?? {};
    final customValues = config['custom-values'] as bool? ?? false;
    final extension = config['extension'] as bool? ?? false;
    final indexedAccess = config['indexed-access'] as bool? ?? false;
    final indexType = config['index-type'] as String? ?? 'String';

    final buffer = StringBuffer();

    // Add class documentation
    if (description.isNotEmpty) {
      buffer.writeln('/// $description');
    }

    // Generate class
    buffer.writeln('class $className {');
    buffer.writeln('  const $className({');

    // Generate constructor parameters
    final fieldNames = <String>[];
    for (final entry in values.entries) {
      final key = entry.key.toString();
      final fieldName = _getFieldName(key);
      fieldNames.add(fieldName);
      buffer.writeln('    required this.$fieldName,');
    }

    if (customValues) {
      buffer.writeln('    this.customValues = const {},');
    }

    buffer.writeln('  });');
    buffer.writeln();

    // Generate field declarations
    for (final entry in values.entries) {
      final key = entry.key.toString();
      final fieldName = _getFieldName(key);
      buffer.writeln('  final $type $fieldName;');
    }

    if (customValues) {
      final customType = indexedAccess
          ? 'Map<$indexType, $type>'
          : 'Map<String, $type>';
      buffer.writeln('  final $customType customValues;');
    }

    buffer.writeln();

    // Generate values getter
    if (indexedAccess) {
      buffer.writeln('  /// Get all values as a map');
      buffer.writeln('  Map<$indexType, $type> get values => {');
      for (final entry in values.entries) {
        final key = entry.key.toString();
        final fieldName = _getFieldName(key);
        final indexValue = _getIndexValue(key, indexType);
        buffer.writeln('    $indexValue: $fieldName,');
      }
      buffer.writeln('  };');
    } else {
      buffer.writeln('  /// Get all values as a map');
      buffer.writeln('  Map<String, $type> get values => {');
      for (final entry in values.entries) {
        final key = entry.key.toString();
        final fieldName = _getFieldName(key);
        final mapKey = key.isEmpty ? "''" : "'$key'";
        buffer.writeln('    $mapKey: $fieldName,');
      }
      if (customValues) {
        buffer.writeln('    ...customValues,');
      }
      buffer.writeln('  };');
    }

    buffer.writeln();

    // Generate operator[] method
    if (indexedAccess) {
      buffer.writeln('  /// Access values by index');
      buffer.writeln(
        '  $type? operator []($indexType index) => values[index];',
      );
    } else {
      buffer.writeln('  /// Access values by key');
      if (customValues) {
        buffer.writeln(
          '  $type? operator [](String key) => values[key] ?? customValues[key];',
        );
      } else {
        buffer.writeln('  $type? operator [](String key) => values[key];');
      }
    }

    buffer.writeln();

    // Generate copyWith method
    buffer.writeln('  /// Create a copy with updated values');
    buffer.writeln('  $className copyWith({');

    for (final entry in values.entries) {
      final key = entry.key.toString();
      final fieldName = _getFieldName(key);
      buffer.writeln('    $type? $fieldName,');
    }

    if (customValues) {
      final customType = indexedAccess
          ? 'Map<$indexType, $type>?'
          : 'Map<String, $type>?';
      buffer.writeln('    $customType customValues,');
    }

    buffer.writeln('  }) {');
    buffer.writeln('    return $className(');

    for (final entry in values.entries) {
      final key = entry.key.toString();
      final fieldName = _getFieldName(key);
      buffer.writeln('      $fieldName: $fieldName ?? this.$fieldName,');
    }

    if (customValues) {
      buffer.writeln('      customValues: customValues ?? this.customValues,');
    }

    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln();

    // Generate static default constant
    buffer.writeln('  /// Default $className instance');
    buffer.writeln(
      '  static const $className default${className.replaceAll('Fly', '')} = $className(',
    );

    for (final entry in values.entries) {
      final key = entry.key.toString();
      final fieldName = _getFieldName(key);
      final value = entry.value;
      final formattedValue = _formatValue(value, type);
      buffer.writeln('    $fieldName: $formattedValue,');
    }

    buffer.writeln('  );');
    buffer.writeln('}');

    // Generate extension if requested
    if (extension) {
      buffer.writeln();
      buffer.writeln(
        '/// Extension on $className to easily override specific values',
      );
      buffer.writeln('extension ${className}Extension on $className {');
      buffer.writeln(
        '  /// Create a new $className instance with specific value overrides',
      );
      buffer.writeln('  $className copyWith({');

      for (final entry in values.entries) {
        final key = entry.key.toString();
        final fieldName = _getFieldName(key);
        buffer.writeln('    $type? $fieldName,');
      }

      if (customValues) {
        final customType = indexedAccess
            ? 'Map<$indexType, $type>?'
            : 'Map<String, $type>?';
        buffer.writeln('    $customType customValues,');
      }

      buffer.writeln('  }) {');
      buffer.writeln('    return $className(');

      for (final entry in values.entries) {
        final key = entry.key.toString();
        final fieldName = _getFieldName(key);
        buffer.writeln('      $fieldName: $fieldName ?? this.$fieldName,');
      }

      if (customValues) {
        buffer.writeln(
          '      customValues: customValues ?? this.customValues,',
        );
      }

      buffer.writeln('    );');
      buffer.writeln('  }');
      buffer.writeln('}');
    }

    return buffer.toString();
  }

  /// Convert key to valid Dart field name
  String _getFieldName(String key) {
    if (key.isEmpty) {
      return 'defaultValue';
    }

    // Handle special cases
    if (key == '2xl') return 'xl2';
    if (key == '3xl') return 'xl3';

    // Handle numeric keys for spacing
    if (RegExp(r'^\d+$').hasMatch(key)) {
      return 's$key';
    }

    // Convert to camelCase and handle numbers
    final parts = key.split(RegExp(r'[^a-zA-Z0-9]+'));
    if (parts.isEmpty) return 'value';

    final firstPart = parts[0].toLowerCase();
    final remainingParts = parts.skip(1).map((part) {
      if (part.isEmpty) return '';
      return part[0].toUpperCase() + part.substring(1).toLowerCase();
    });

    return firstPart + remainingParts.join('');
  }

  /// Convert key to index value for indexed access
  String _getIndexValue(String key, String indexType) {
    if (indexType == 'int') {
      return key;
    }
    return "'$key'";
  }

  /// Format value based on type
  String _formatValue(dynamic value, String type) {
    if (type == 'String') {
      return "'$value'";
    }
    return value.toString();
  }
}
